# crossbeam_deque

https://github.com/crossbeam-rs/crossbeam.git

work-stealing算法是一种实现任务并行的算法，主要用于多核处理器.
主要思想：当某个处理器的任务执行完毕后，他可以从其他处理器的任务队列中偷取一些任务来执行，以充分利用系统资源，提高系统的并行度和性能。
## working-stealing算法实质
通常是一个双端队列的数据结构。每个处理器都有自己的任务队列，也就是双端队列的一端，该队列用于存放自己的任务。当一个处理器处理完自己的任务后，他会从其他处理器的队列中随即选择一些任务。如果其他处理器的队列中没有任务可偷，则该处理器会轮询其他队列，指导找到可以偷的为止。
work-stealing算法的优点在于它可以充分利用系统资源，提高系统的并行度和性能。它不需要进行任务调度，因为每个处理器都可以自主选择要执行的任务，这样可以减少任务调度的开销。同时，它也可以避免任务之间的互斥和同步问题，因为每个任务都是独立的，没有共享的状态。
需要注意的是，在使用work-stealing算法时，需要考虑任务的负载均衡问题。如果某个处理器的任务比其他处理器的任务多，那么它就会成为系统的瓶颈，导致系统的性能下降。因此，需要采取一些策略来均衡任务的分配，使得每个处理器的任务负载尽可能均衡。

crossbeam-deque包提供了一个无锁双向队列（deque）。那么这个双向队列在并发中起到什么作用？
"crossbeam-deque"是Crossbeam库中的一个模块，用于实现无锁的双端队列（deque）。Deque是一种数据结构，支持在队列的两端进行插入和删除操作。
Crossbeam-deque提供了一种高效的无锁实现，可以在多个线程之间进行并发访问。它使用一种基于追加-弹出（push-pop）操作的算法，可以在多个线程之间高效地共享和处理任务。
Crossbeam-deque的主要特点包括：

无锁：使用了一套无锁算法，没有互斥锁的开销，适合高并发环境。
双端操作：支持在队列的两端进行插入和删除操作，可以根据需要选择合适的操作。
高效：通过使用CAS（Compare and Swap）原子指令来实现并发操作，提供了高性能的并发处理能力。
可扩展：可以动态地增加或减少队列的容量，以适应不同的并发负载。
使用Crossbeam-deque可以方便地构建并发任务调度器、工作线程池等并发应用。它提供了一种无锁的队列实现，可以在多个线程之间高效地共享和处理任务。

```rust
crossbeam::scope(|s| {
    s.spawn(|_| {
        for i in 0..n_msgs {
            snd.send(i).unwrap();
            thread::sleep(time::Duration::from_millis(100));
        }
    });
}).unwrap();
```
crossbeam scope函数来创建一个线程作用域，确保在作用域结束后所有的子线程都已经完成。在作用域中，使用spawn函数创建了一个新的子线程，并在子线程中循环发送数据。
使用crossbeam的scope函数创建了一个线程作用域。scope函数接受一个闭包作为参数，并在闭包中创建子线程。

在作用域中，使用spawn函数创建了一个新的子线程。spawn函数接受一个闭包作为参数，并在子线程中执行该闭包。

子线程的闭包使用for循环发送数据到snd通道，并使用thread::sleep函数休眠100毫秒。

使用unwrap函数处理可能的错误，确保操作成功。
通过这段代码，可以在一个作用域中创建子线程，并在子线程中发送一系列数据到通道。使用crossbeam的scope函数可以有效地管理线程的生命周期，并确保在作用域结束后所有的子线程都已经完成。

crossbeam crate中的scope函数提供了一种方便的方式来创建线程作用域，它的原理和作用如下原理：
scope函数使用了Rust的生命周期（lifetime）机制来管理线程的生命周期。
在scope函数的闭包中创建的子线程，其生命周期与scope函数的生命周期相同，也就是说，在scope函数执行完毕后，所有在scope闭包中创建的子线程都会被等待并加以回收。
作用：
线程作用域（thread scope）是一种用于管理线程生命周期的模式。它可以确保在作用域结束后，所有的子线程都已经完成并被回收，避免了线程的泄漏或提前终止。
使用scope函数可以避免手动创建和管理线程的问题，以及手动等待和回收线程的麻烦。
在scope函数的作用域内，可以方便地创建多个子线程，并在子线程中执行需要的操作，无需手动管理线程的生命周期。
scope函数还能够有效地避免资源竞争问题，因为所有的子线程都在作用域结束后被回收，不会在作用域外继续执行。
总之，crossbeam crate中的scope函数通过利用Rust的生命周期机制，提供了一种方便、安全和高效的方式来管理线程的生命周期，避免了手动管理线程和资源竞争的问题。它是在并发编程中非常有用的工具。

# 维护全局可状态变
