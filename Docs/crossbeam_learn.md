# crossbeam_deque

https://github.com/crossbeam-rs/crossbeam.git

work-stealing算法是一种实现任务并行的算法，主要用于多核处理器.
主要思想：当某个处理器的任务执行完毕后，他可以从其他处理器的任务队列中偷取一些任务来执行，以充分利用系统资源，提高系统的并行度和性能。
## working-stealing算法实质
通常是一个双端队列的数据结构。每个处理器都有自己的任务队列，也就是双端队列的一端，该队列用于存放自己的任务。当一个处理器处理完自己的任务后，他会从其他处理器的队列中随即选择一些任务。如果其他处理器的队列中没有任务可偷，则该处理器会轮询其他队列，指导找到可以偷的为止。
work-stealing算法的优点在于它可以充分利用系统资源，提高系统的并行度和性能。它不需要进行任务调度，因为每个处理器都可以自主选择要执行的任务，这样可以减少任务调度的开销。同时，它也可以避免任务之间的互斥和同步问题，因为每个任务都是独立的，没有共享的状态。
需要注意的是，在使用work-stealing算法时，需要考虑任务的负载均衡问题。如果某个处理器的任务比其他处理器的任务多，那么它就会成为系统的瓶颈，导致系统的性能下降。因此，需要采取一些策略来均衡任务的分配，使得每个处理器的任务负载尽可能均衡。

crossbeam-deque包提供了一个无锁双向队列（deque）。那么这个双向队列在并发中起到什么作用？
"crossbeam-deque"是Crossbeam库中的一个模块，用于实现无锁的双端队列（deque）。Deque是一种数据结构，支持在队列的两端进行插入和删除操作。
Crossbeam-deque提供了一种高效的无锁实现，可以在多个线程之间进行并发访问。它使用一种基于追加-弹出（push-pop）操作的算法，可以在多个线程之间高效地共享和处理任务。
Crossbeam-deque的主要特点包括：

无锁：使用了一套无锁算法，没有互斥锁的开销，适合高并发环境。
双端操作：支持在队列的两端进行插入和删除操作，可以根据需要选择合适的操作。
高效：通过使用CAS（Compare and Swap）原子指令来实现并发操作，提供了高性能的并发处理能力。
可扩展：可以动态地增加或减少队列的容量，以适应不同的并发负载。
使用Crossbeam-deque可以方便地构建并发任务调度器、工作线程池等并发应用。它提供了一种无锁的队列实现，可以在多个线程之间高效地共享和处理任务。
